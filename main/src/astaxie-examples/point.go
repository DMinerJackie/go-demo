package main

import "fmt"

//简单的一个函数，实现了参数+1的操作
func add1(a int) int {
	a = a + 1 // 我们改变了a的值
	return a  //返回一个新值
}

/**
我们知道，变量在内存中是存放于一定地址上的，修改变量实际是修改变量地址处的内存。
只有add1函数知道x变量所在的地址，才能修改x变量的值。所以我们需要将x所在地址&x传入函数，
并将函数的参数的类型由int改为*int，即改为指针类型，才能在函数中修改x变量的值。
此时参数仍然是按copy传递的，只是copy的是一个指针
*/
//简单的一个函数，实现了参数+1的操作
func add2(a *int) int { // 请注意，
	*a = *a + 1 // 修改了a的值
	return *a   // 返回新值
}

func main() {
	x := 3

	fmt.Println("x = ", x) // 应该输出 "x = 3"

	x1 := add1(x) //调用add1(x)

	fmt.Println("x+1 = ", x1) // 应该输出"x+1 = 4"
	fmt.Println("x = ", x)    // 应该输出"x = 3"

	y := 3

	fmt.Println("y = ", y) // 应该输出 "y = 3"

	y1 := add2(&y) // 调用 add1(&y) 传y的地址

	fmt.Println("y+1 = ", y1) // 应该输出 "y+1 = 4"
	fmt.Println("y = ", y)    // 应该输出 "y = 4"

	/**
	这样，我们就达到了修改x的目的。那么到底传指针有什么好处呢？

	传指针使得多个函数能操作同一个对象。
	传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。
	Go语言中channel，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）
	*/
}
